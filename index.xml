<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Youzhe Liu</title>
    <link>https://alanSquirrelyz.github.io/</link>
    <description>Recent content on Youzhe Liu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 15 Oct 2022 09:07:01 -0700</lastBuildDate>
    
	<atom:link href="https://alanSquirrelyz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    <item>
      <title>Cpp Priority_queue_customize</title>
      <link>https://alanSquirrelyz.github.io/cpp-priority_queue_customize/</link>
      <pubDate>Sat, 15 Oct 2022 09:07:01 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/cpp-priority_queue_customize/</guid>
      <description>&lt;h1 id=&#34;techniques-for-customizing-priority_queue-in-c-stl&#34;&gt;Techniques for customizing &lt;code&gt;priority_queue&lt;/code&gt; in C++ STL&lt;/h1&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt; is a container adaptor in C++ STL. It provides an order for elements in queue, taking the advantage of the data structure &lt;code&gt;heap&lt;/code&gt;. The comparing (the order to keep the queue) can be customized and it is very useful in some cases to make algorithms more quick and efficient. Here are some summarize about the customization, as well as some of mt own understandings.&lt;/p&gt;
&lt;p&gt;Here is the complete initializing template for &lt;code&gt;priority_queue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;
    class T,
    class Container = std::vector&amp;lt;T&amp;gt;,
    class Compare = std::less&amp;lt;typename Container::value_type&amp;gt;
&amp;gt; class priority_queue;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Priority_queue is very supportive solving problems using greedy algorithms. But sometimes the problems are tricky to use a integer only, so priority queue with self-designed order is very sharp for these occasions.&lt;/p&gt;
&lt;p&gt;Some contents are based on &lt;a href=&#34;https://en.cppreference.com/w/cpp/container/priority_queue&#34;&gt;cppreference&lt;/a&gt; and some blogs on Internet.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Basic Valgrind Usage</title>
      <link>https://alanSquirrelyz.github.io/basic-valgrind-usage/</link>
      <pubDate>Mon, 03 Oct 2022 12:08:45 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/basic-valgrind-usage/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Valgrind is a tool for analysing the instrumental framework for building dynamic analysis tools, developed by Julian Seward.&lt;/p&gt;
&lt;p&gt;Most of the contents in this blog are from the &lt;a href=&#34;https://valgrind.org/&#34;&gt;Valgrind official&lt;/a&gt; website.&lt;/p&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;h3 id=&#34;compiling&#34;&gt;Compiling&lt;/h3&gt;
&lt;p&gt;Before using Valgrind, we need to compile our programs with &lt;code&gt;-g&lt;/code&gt; option, which means the compiling will include the
detailed debug informations (Memchecks&#39; erroe messgaes with exact line numbers will be included). Note that &lt;code&gt;-O0&lt;/code&gt; and &lt;code&gt;-O1&lt;/code&gt;
also works, while it is not recommended to use &lt;code&gt;-O2&lt;/code&gt; and above.&lt;/p&gt;
&lt;h3 id=&#34;running-under-memcheck&#34;&gt;Running under Memcheck&lt;/h3&gt;
&lt;p&gt;In the normal case we just run our programs as this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myprog arg1 arg2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we need to run the following command to involve Valgrind:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;valgrind --leak-check=yes myprog arg1 arg2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that in this way our programs may be a lot slower than running dependently since Valgrind needs to detect memory errors.&lt;/p&gt;
&lt;h3 id=&#34;an-example&#34;&gt;An Example&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;stdlib.h&amp;gt;

  void f(void)
  {
     int* x = malloc(10 * sizeof(int));
     x[10] = 0;        // problem 1: heap block overrun
  }                    // problem 2: memory leak -- x not freed

  int main(void)
  {
     f();
     return 0;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The memory messages are like following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==19182== Invalid write of size 4
==19182==    at 0x804838F: f (example.c:6)
==19182==    by 0x80483AB: main (example.c:11)
==19182==  Address 0x1BA45050 is 0 bytes after a block of size 40 alloc&#39;d
==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
==19182==    by 0x8048385: f (example.c:5)
==19182==    by 0x80483AB: main (example.c:11)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Actually there will be lots of information in each message indelendently, so we need to read them seperately for
finding the detailed error, as well as the bugs related to them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The number in each message denotes the process ID, which is not the key point.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The first line of each message denotes the type of the error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The following line denotes the position of the error (as stack trace).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All the memory errors may not cause a error for compiler overall. But it is a error, as well as a bug. So it is better to treat them carefully.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memory-leak&#34;&gt;Memory Leak&lt;/h3&gt;
&lt;p&gt;Here is an example for memory leak problem.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ==19182== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (a.c:5)
  ==19182==    by 0x80483AB: main (a.c:11)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see from the stack trace where the leaked memory will be allocated, but we cannot know the reason from Memcheck directly.&lt;/p&gt;
&lt;p&gt;The leak will be divided into two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;definitely lost&amp;rdquo;: it is obvious that the memory was leaked so necessary to fix it.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;probably lost&amp;rdquo;: it also means that the memory is leaked, except some pointer oprations, which are also not smart.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;conditional-jump-or-move-depends-on-uninitialised-values&#34;&gt;&amp;ldquo;Conditional jump or move depends on uninitialised value(s)&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;This is a common message that may happen a lot, which means the uses of uninitialised values. It is difficult to find where the root cause is, but using &lt;code&gt;--track-origin=yes&lt;/code&gt; will tell us extra informations that helps us locate them.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Valgrind is a powerful framework with a lot more than this. So
TO BE CONTINUED&lt;/p&gt;
</description>
    </item>
    
    
    
    
  </channel>
</rss>
