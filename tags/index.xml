<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tags on Youzhe Liu</title>
    <link>https://alanSquirrelyz.github.io/tags/</link>
    <description>Recent content in Tags on Youzhe Liu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://alanSquirrelyz.github.io/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    <item>
      <title>Fake Poems</title>
      <link>https://alanSquirrelyz.github.io/fake-poems/</link>
      <pubDate>Tue, 11 Apr 2023 19:44:02 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/fake-poems/</guid>
      <description>&lt;h3 id=&#34;沈杜公路&#34;&gt;沈杜公路&lt;/h3&gt;
&lt;p&gt;04/11/2023&lt;/p&gt;
&lt;p&gt;列车匆匆穿过
南京西路的咖啡
古北别墅的地基
一望无尽的平原
孤独又单纯的地铁站
同一趟公交车
同样的吴侬软语
消失的青春岁岁
消失的鼾声
埋在闵浦大桥的浅滩
埋在雪花中&lt;/p&gt;
&lt;h3 id=&#34;他&#34;&gt;他&lt;/h3&gt;
&lt;p&gt;05/10/2023
他四天前刚过了23岁生日
他那一天多巴胺降到冰点
我在暗处窥探
觉得可笑又羞愧
我爱他 这个生活在我身后的影子
他恨我 这个从不敢看影子的孩子&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Randomized Incremental for Trapezoidal Decomposition</title>
      <link>https://alanSquirrelyz.github.io/randomized-incremental-for-trapezoidal-decomposition/</link>
      <pubDate>Wed, 22 Mar 2023 12:57:07 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/randomized-incremental-for-trapezoidal-decomposition/</guid>
      <description>&lt;p&gt;check the notes for randomized incremental algorithm for trapezoidal decomposition &lt;a href=&#34;https://alanSquirrelyz.github.io/notes_PDF/TrapezoidalIncremental.pdf&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Cpp Priority_queue_customize</title>
      <link>https://alanSquirrelyz.github.io/cpp-priority_queue_customize/</link>
      <pubDate>Sat, 15 Oct 2022 09:07:01 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/cpp-priority_queue_customize/</guid>
      <description>&lt;h1 id=&#34;techniques-for-customizing-priority_queue-in-c-stl&#34;&gt;Techniques for customizing &lt;code&gt;priority_queue&lt;/code&gt; in C++ STL&lt;/h1&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt; is a container adaptor in C++ STL. It provides an order for elements in queue, taking the advantage of the data structure &lt;code&gt;heap&lt;/code&gt;. The comparing (the order to keep the queue) can be customized and it is very useful in some cases to make algorithms more quick and efficient. Here are some summarize about the customization, as well as some of mt own understandings.&lt;/p&gt;
&lt;p&gt;Here is the complete initializing template for &lt;code&gt;priority_queue&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;template&amp;lt;
    class T,
    class Container = std::vector&amp;lt;T&amp;gt;,
    class Compare = std::less&amp;lt;typename Container::value_type&amp;gt;
&amp;gt; class priority_queue;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Priority_queue is very supportive solving problems using greedy algorithms. But sometimes the problems are tricky to use a integer only, so priority queue with self-designed order is very sharp for these occasions.&lt;/p&gt;
&lt;p&gt;Some contents are based on &lt;a href=&#34;https://en.cppreference.com/w/cpp/container/priority_queue&#34;&gt;cppreference&lt;/a&gt; and some blogs on Internet.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Basic Valgrind Usage</title>
      <link>https://alanSquirrelyz.github.io/basic-valgrind-usage/</link>
      <pubDate>Mon, 03 Oct 2022 12:08:45 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/basic-valgrind-usage/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Valgrind is a tool for analysing the instrumental framework for building dynamic analysis tools, developed by Julian Seward.&lt;/p&gt;
&lt;p&gt;Most of the contents in this blog are from the &lt;a href=&#34;https://valgrind.org/&#34;&gt;Valgrind official&lt;/a&gt; website.&lt;/p&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;h3 id=&#34;compiling&#34;&gt;Compiling&lt;/h3&gt;
&lt;p&gt;Before using Valgrind, we need to compile our programs with &lt;code&gt;-g&lt;/code&gt; option, which means the compiling will include the
detailed debug informations (Memchecks&amp;rsquo; erroe messgaes with exact line numbers will be included). Note that &lt;code&gt;-O0&lt;/code&gt; and &lt;code&gt;-O1&lt;/code&gt;
also works, while it is not recommended to use &lt;code&gt;-O2&lt;/code&gt; and above.&lt;/p&gt;
&lt;h3 id=&#34;running-under-memcheck&#34;&gt;Running under Memcheck&lt;/h3&gt;
&lt;p&gt;In the normal case we just run our programs as this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myprog arg1 arg2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we need to run the following command to involve Valgrind:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;valgrind --leak-check=yes myprog arg1 arg2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that in this way our programs may be a lot slower than running dependently since Valgrind needs to detect memory errors.&lt;/p&gt;
&lt;h3 id=&#34;an-example&#34;&gt;An Example&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  #include &amp;lt;stdlib.h&amp;gt;

  void f(void)
  {
     int* x = malloc(10 * sizeof(int));
     x[10] = 0;        // problem 1: heap block overrun
  }                    // problem 2: memory leak -- x not freed

  int main(void)
  {
     f();
     return 0;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The memory messages are like following:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;==19182== Invalid write of size 4
==19182==    at 0x804838F: f (example.c:6)
==19182==    by 0x80483AB: main (example.c:11)
==19182==  Address 0x1BA45050 is 0 bytes after a block of size 40 alloc&amp;#39;d
==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
==19182==    by 0x8048385: f (example.c:5)
==19182==    by 0x80483AB: main (example.c:11)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Actually there will be lots of information in each message indelendently, so we need to read them seperately for
finding the detailed error, as well as the bugs related to them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The number in each message denotes the process ID, which is not the key point.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The first line of each message denotes the type of the error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The following line denotes the position of the error (as stack trace).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All the memory errors may not cause a error for compiler overall. But it is a error, as well as a bug. So it is better to treat them carefully.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memory-leak&#34;&gt;Memory Leak&lt;/h3&gt;
&lt;p&gt;Here is an example for memory leak problem.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  ==19182== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (a.c:5)
  ==19182==    by 0x80483AB: main (a.c:11)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see from the stack trace where the leaked memory will be allocated, but we cannot know the reason from Memcheck directly.&lt;/p&gt;
&lt;p&gt;The leak will be divided into two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;definitely lost&amp;rdquo;: it is obvious that the memory was leaked so necessary to fix it.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;probably lost&amp;rdquo;: it also means that the memory is leaked, except some pointer oprations, which are also not smart.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;conditional-jump-or-move-depends-on-uninitialised-values&#34;&gt;&amp;ldquo;Conditional jump or move depends on uninitialised value(s)&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;This is a common message that may happen a lot, which means the uses of uninitialised values. It is difficult to find where the root cause is, but using &lt;code&gt;--track-origin=yes&lt;/code&gt; will tell us extra informations that helps us locate them.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The following part includes some typical error type from Valgrind.&lt;/p&gt;
&lt;h3 id=&#34;illegal-read--illegal-write-errors&#34;&gt;Illegal read / Illegal write errors&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  Invalid read of size 4
     at 0x40F6BBCC: (within /usr/lib/libpng.so.2.1.0.9)
     by 0x40F6B804: (within /usr/lib/libpng.so.2.1.0.9)
     by 0x40B07FF4: read_png_image__FP8QImageIO (kernel/qpngio.cpp:326)
     by 0x40AC751B: QImageIO::read() (kernel/qimage.cpp:3621)
     Address 0xBFFFF0E0 is not stack&amp;#39;d, malloc&amp;#39;d or free&amp;#39;d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This happens when the program reads or writes memory at a plce which Memcheck reckons it shouldn&amp;rsquo;t. Normally when you try to read or write pointed to a part that has already been freed, you&amp;rsquo;ll be informed with this message.&lt;/p&gt;
&lt;p&gt;In some cases, the program will lives well with the actually not valid access since we are allowed to read or write to a garbage area (non-fatal error). So when something goes wrong with the output, we may just check the Valgrind output to see whether there is a memory read/write error.&lt;/p&gt;
&lt;h3 id=&#34;use-of-uninitialised-values&#34;&gt;Use of uninitialised values&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  Conditional jump or move depends on uninitialised value(s)
     at 0x402DFA94: _IO_vfprintf (_itoa.h:49)
     by 0x402E8476: _IO_printf (printf.c:36)
     by 0x8048472: main (tests/manuel1.c:8)
     by 0x402A6E5E: __libc_start_main (libc-start.c:129)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;`Uninitialsed value&amp;rsquo; is also a common error that is not easy to find. Sometimes the variable will be read with wrong value thought the memory access is valid.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Here is an error that is not easy to be found but easy to appear: sometimes we put several judge statement in a single &lt;code&gt;if&lt;/code&gt;, then the more necessary conditions
conditions should be put first, i.e., the conditions rely on the previous one should be placed after.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;illegal-frees&#34;&gt;Illegal frees&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  Invalid free()
     at 0x4004FFDF: free (vg_clientmalloc.c:577)
     by 0x80484C7: main (tests/doublefree.c:10)
     by 0x402A6E5E: __libc_start_main (libc-start.c:129)
     by 0x80483B1: (within tests/doublefree)
     Address 0x3807F7B4 is 0 bytes inside a block of size 177 free&amp;#39;d
     at 0x4004FFDF: free (vg_clientmalloc.c:577)
     by 0x80484C7: main (tests/doublefree.c:10)
     by 0x402A6E5E: __libc_start_main (libc-start.c:129)
     by 0x80483B1: (within tests/doublefree)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Memcheck keeps track of the blocks allocated by your program with malloc/new, so it can know exactly whether or not the argument to free/delete is legitimate or not. Here, this test program has freed the same block twice. As with the illegal read/write errors, Memcheck attempts to make sense of the address free&amp;rsquo;d. If, as here, the address is one which has previously been freed, you wil be told that &amp;ndash; making duplicate frees of the same block easy to spot.&lt;/p&gt;
&lt;h3 id=&#34;overlapping-source-and-destination-blocks&#34;&gt;Overlapping source and destination blocks&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;==27492== Source and destination overlap in memcpy(0xbffff294, 0xbffff280, 21)
==27492==    at 0x40026CDC: memcpy (mc_replace_strmem.c:71)
==27492==    by 0x804865A: main (overlap.c:40)
==27492==    by 0x40246335: __libc_start_main (../sysdeps/generic/libc-start.c:129)
==27492==    by 0x8048470: (within /auto/homes/njn25/grind/head6/memcheck/tests/overlap)
==27492== 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The C library functions above copy some data from one memory block to another (or something similar): memcpy(), strcpy(), strncpy(), strcat(), strncat(). The blocks pointed to by their src and dst pointers aren&amp;rsquo;t allowed to overlap. Memcheck checks for this.&lt;/p&gt;
&lt;h2 id=&#34;some-tricks&#34;&gt;Some Tricks&lt;/h2&gt;
&lt;h3 id=&#34;how-to-stop-at-the-first-error&#34;&gt;How to Stop at the First Error&lt;/h3&gt;
&lt;p&gt;If we want to stop at the console to see where the error occured:&lt;/p&gt;
&lt;p&gt;Use the parameter : &lt;code&gt;--gen-suppressions=yes&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;some-tutorials&#34;&gt;Some tutorials:&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://valgrind.org/docs/manual/manual.html&#34;&gt;https://valgrind.org/docs/manual/manual.html&lt;/a&gt;
&lt;a href=&#34;http://cs.ecs.baylor.edu/~donahoo/tools/valgrind/&#34;&gt;http://cs.ecs.baylor.edu/~donahoo/tools/valgrind/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    
  </channel>
</rss>
