<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tags on Youzhe Liu</title>
    <link>https://alanSquirrelyz.github.io/tags/</link>
    <description>Recent content in Tags on Youzhe Liu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://alanSquirrelyz.github.io/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    <item>
      <title>Mem In_Shanghai</title>
      <link>https://alanSquirrelyz.github.io/mem-in_shanghai/</link>
      <pubDate>Mon, 09 Jan 2023 21:51:24 -0800</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/mem-in_shanghai/</guid>
      <description>&lt;h1 id=&#34;memory-in-shanghai-of-youzhe&#34;&gt;Memory in Shanghai, of Youzhe&lt;/h1&gt;
&lt;p&gt;ä»Šæ—¥ç¿»çœ‹æ‰‹æœºç›¸ç‰‡ï¼Œå¾ˆå¤šä¸Šæµ·éšæ‰‹æ‹çš„ç…§ç‰‡å‹¾èµ·äº†å¾ˆå¤šè®°å¿†ï¼Œå®åœ¨éš¾ä»¥å¿˜æ€€ä¸Šæµ·çš„å››å¹´ç”Ÿæ´»&lt;/p&gt;
&lt;p&gt;åœ¨ä¸Šæµ·çš„ç¬¬ä¸€ä¸ªæ¸…æ˜ï¼Œå’Œä¸ğŸŸä¸€èµ·å»éª‘è¡Œäº†å¤§åŠä¸ªä¸Šæµ·ï¼Œä»æ—©ä¸Šä¸€ç›´åˆ°å‚æ™šæ‰å›å­¦æ ¡ï¼Œå¯¹ä¸Šæµ·çš„ç¬¬ä¸€å°è±¡æ˜¯æ˜åªšã€é²œè‰³ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh15.jpeg&#34; alt=&#34;First Spring in Shanghai&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2019å¹´4æœˆï¼›COVIDå‰)&lt;/p&gt;
&lt;p&gt;åœ¨ä¸Šæµ·çš„ç¬¬ä¸€ä¸ªå†¬å¤©ï¼Œè®°å¾—æ˜¯æ”¾å‡å›å®¶çš„å‰ä¸€å¤©ã€‚é‚£æ—¶å€™Mannerè¿˜æ²¡æœ‰æˆç½‘çº¢å“ç‰Œï¼Œåœ¨ä¸€å®¶å¾ˆå°çš„Mannerä¹°çš„æ¾³ç™½ï¼Œé›¾è’™è’™çš„å¤©æ°”ã€‚ä¹Ÿç®—æ˜¯è§è¯äº†Manneråœ¨ä¸Šæµ·çš„å‘å±•ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh14.JPG&#34; alt=&#34;Riverside Shanghai&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2018å¹´å†¬ï¼›COVIDå‰)&lt;/p&gt;
&lt;p&gt;åœ¨ä¸Šæµ·çš„ç¬¬ä¸€ä»½å®ä¹ ï¼Œæœ€åä¸€å¤©æ—¶æ‘„äºç§Ÿçš„å…¬å¯“é—¨å£åœ°é“ç«™ã€‚ç¡®å®æ˜¯éš¾å¿˜çš„å›å¿†ï¼Œæ­¤æ—¶æˆ‘å¤„äºæŠ‘éƒå‰å¤•ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh5.JPG&#34; alt=&#34;Shanghai Sunset&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2020å¹´å¤ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;æ‘„äºä¸Šæµ·ä¹¦åŸï¼Œå¶ç„¶æŠ“æ‹åˆ°çš„æœ‰è¶£ç”»é¢ã€‚ç–«æƒ…åä¸Šæµ·ä¹¦åŸè¿™ä¸ªå…¨å›½æœ€å¤§çš„ä¹¦åº—å·²ç»å®£å¸ƒåœä¸šï¼Œå¤§ä¸€å¤§äºŒæ—¶åœ¨é‚£é‡Œè¿˜æ˜¯ç•™ä¸‹ä¸å°‘å›å¿†ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh1.jepg&#34; alt=&#34;Shanghai Bookstore&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2019å¹´ç§‹ï¼›COVIDå‰)&lt;/p&gt;
&lt;p&gt;å’Œè”šç„¶æœ€å–œæ¬¢ã€ä¹Ÿæ¥æ¥å›å›èµ°äº†å¾ˆå¤šæ¬¡çš„åŒ—å¤–æ»©ï¼Œè™¹å£æ»¨æ±Ÿã€‚å¾ˆå¤šå–èŠ±çš„å°åº—ã€æ—§è´§è½®ã€æ—è¾¹æ˜¯é«˜è€¸çš„æ¥ç¦å£«å¤§æ¥¼å’Œç´§ä»„çš„è€åŸå°è·¯ï¼ŒçœŸæ­£çš„ä¸Šæµ·ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh4.jpg&#34; alt=&#34;Shanghai Sunset&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2022å¹´æ˜¥ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;ä¸Šæµ·è¥ä¸šé¢æœ€é«˜çš„å•†åœºç¯çƒæ¸¯ï¼Œç”±äºåœ¨åå¸ˆå¤§é—¨å£ï¼Œé€›åƒäº†æ— æ•°æ¬¡ï¼Œå¯¹å†…éƒ¨çš„é¤å…äº†å¦‚æŒ‡æŒã€‚ä¸çŸ¥é“ç°åœ¨è¿˜æœ‰å‡ å®¶å¼€ç€ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh8.JPG&#34; alt=&#34;Shanghai Global Harbor&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2021å¹´å†¬ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;ä¸´æ—¶å¾—çŸ¥NEO Baråœä¸šå‰æœ€åä¸€å¤©è¥ä¸šï¼›35åº¦çš„ä¸œäº¬èŒ¶ï¼›å’Œæ•æ€»å–é†‰ï¼›å¤±å»äº†ä¸€æ™šçš„è®°å¿†
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh9.jpg&#34; alt=&#34;NEO Bar&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2022å¹´æ˜¥ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;æ¯•ä¸šå…¸ç¤¼å½“å¤©å»äº†å­¦æ ¡æ–‡å›¾é—¨å£çš„The Pressè‡ªä¹ äº†æœ€åä¸€æ¬¡ï¼Œå¤§å­¦æœŸé—´çš„å°èµ„æ—¶å…‰ï¼›æœ€å–œæ¬¢çš„å’–å•¡åº—
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh11.JPG&#34; alt=&#34;The Press&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2022å¹´å¤ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;å¤§ä¸‰æš‘å‡æ³¡äº†ä¸€å¤å¤©çš„å¥èº«æˆ¿ï¼Œåœ¨å¤æ—¦15å¹³ç±³çš„å¥èº«æˆ¿ç»ƒå‡ºäº†è¿˜ä¸é”™çš„è‚Œè‚‰ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh3.jpg&#34; alt=&#34;Gym&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2021å¹´å¤ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;æœ€å–œæ¬¢çš„Tacoï¼Œå¤§å­¦æœŸé—´åƒäº†ä¸Šç™¾æ¬¡ï¼Œå¿˜ä¸äº†å‘¨äºŒçš„äº”å—ä¸€ä¸ªçš„Tacoã€‚æ¥äº†åŠ å·åè€Œè§‰å¾—æ­£å®—çš„tacoå°‘äº†äº›è®°å¿†ä¸­çš„å‘³é“ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh12.JPG&#34; alt=&#34;Lambamba&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2021å¹´å†¬ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;åœ¨å¾®è½¯å®ä¹ çš„æ‘¸é±¼æ—¶å…‰ï¼Œå¾ˆå¼€å¿ƒåœ¨å……æ»¡æ´»åŠ›çš„VS Codeç»„å­¦åˆ°äº†ä¸å°‘ä¼ä¸šçº§å¼€å‘çš„æŠ€èƒ½å’Œå›¢é˜Ÿç²¾ç¥ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh2.jpg&#34; alt=&#34;Intern at Microsoft&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2021å¹´å¤ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;å¤§å­¦æœŸé—´å½¢å½±ä¸ç¦»çš„ä¸‰ä¸ªæœ‹å‹ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh6.jpg&#34; alt=&#34;Friends&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2022å¹´æ˜¥ï¼›COVIDåï¼ˆå°æ ¡æœŸé—´ï¼‰)&lt;/p&gt;
&lt;p&gt;å®ä¹ æ—¶åç­è½¦å›å®¶ï¼Œè·¯è¿‡æ¨æµ¦å¤§æ¡¥ï¼Œæ·±åˆ»æ„Ÿå—åˆ°åœ¨è¿™åº§å·¨å‹éƒ½å¸‚æ¯ä¸ªäººçš„æ¸ºå°ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh7.jpg&#34; alt=&#34;Shanghai Night&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2021å¹´å¤ï¼›COVIDå)&lt;/p&gt;
&lt;p&gt;æ¯•ä¸šã€‚é’æ˜¥éšéšçº¦çº¦å¥½åƒç»“æŸäº†ã€‚
&lt;img src=&#34;https://alanSquirrelyz.github.io/photos/sh10.JPG&#34; alt=&#34;Graduation&#34;&gt;
(å›¾ç‰‡å¤§æ¦‚æ‘„äº2022å¹´å¤ï¼›COVIDå)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Cpp Priority_queue_customize</title>
      <link>https://alanSquirrelyz.github.io/cpp-priority_queue_customize/</link>
      <pubDate>Sat, 15 Oct 2022 09:07:01 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/cpp-priority_queue_customize/</guid>
      <description>&lt;h1 id=&#34;techniques-for-customizing-priority_queue-in-c-stl&#34;&gt;Techniques for customizing &lt;code&gt;priority_queue&lt;/code&gt; in C++ STL&lt;/h1&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt; is a container adaptor in C++ STL. It provides an order for elements in queue, taking the advantage of the data structure &lt;code&gt;heap&lt;/code&gt;. The comparing (the order to keep the queue) can be customized and it is very useful in some cases to make algorithms more quick and efficient. Here are some summarize about the customization, as well as some of mt own understandings.&lt;/p&gt;
&lt;p&gt;Here is the complete initializing template for &lt;code&gt;priority_queue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template&amp;lt;
    class T,
    class Container = std::vector&amp;lt;T&amp;gt;,
    class Compare = std::less&amp;lt;typename Container::value_type&amp;gt;
&amp;gt; class priority_queue;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Priority_queue is very supportive solving problems using greedy algorithms. But sometimes the problems are tricky to use a integer only, so priority queue with self-designed order is very sharp for these occasions.&lt;/p&gt;
&lt;p&gt;Some contents are based on &lt;a href=&#34;https://en.cppreference.com/w/cpp/container/priority_queue&#34;&gt;cppreference&lt;/a&gt; and some blogs on Internet.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Basic Valgrind Usage</title>
      <link>https://alanSquirrelyz.github.io/basic-valgrind-usage/</link>
      <pubDate>Mon, 03 Oct 2022 12:08:45 -0700</pubDate>
      
      <guid>https://alanSquirrelyz.github.io/basic-valgrind-usage/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Valgrind is a tool for analysing the instrumental framework for building dynamic analysis tools, developed by Julian Seward.&lt;/p&gt;
&lt;p&gt;Most of the contents in this blog are from the &lt;a href=&#34;https://valgrind.org/&#34;&gt;Valgrind official&lt;/a&gt; website.&lt;/p&gt;
&lt;h2 id=&#34;basic&#34;&gt;Basic&lt;/h2&gt;
&lt;h3 id=&#34;compiling&#34;&gt;Compiling&lt;/h3&gt;
&lt;p&gt;Before using Valgrind, we need to compile our programs with &lt;code&gt;-g&lt;/code&gt; option, which means the compiling will include the
detailed debug informations (Memchecks&#39; erroe messgaes with exact line numbers will be included). Note that &lt;code&gt;-O0&lt;/code&gt; and &lt;code&gt;-O1&lt;/code&gt;
also works, while it is not recommended to use &lt;code&gt;-O2&lt;/code&gt; and above.&lt;/p&gt;
&lt;h3 id=&#34;running-under-memcheck&#34;&gt;Running under Memcheck&lt;/h3&gt;
&lt;p&gt;In the normal case we just run our programs as this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myprog arg1 arg2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we need to run the following command to involve Valgrind:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;valgrind --leak-check=yes myprog arg1 arg2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that in this way our programs may be a lot slower than running dependently since Valgrind needs to detect memory errors.&lt;/p&gt;
&lt;h3 id=&#34;an-example&#34;&gt;An Example&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  #include &amp;lt;stdlib.h&amp;gt;

  void f(void)
  {
     int* x = malloc(10 * sizeof(int));
     x[10] = 0;        // problem 1: heap block overrun
  }                    // problem 2: memory leak -- x not freed

  int main(void)
  {
     f();
     return 0;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The memory messages are like following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==19182== Invalid write of size 4
==19182==    at 0x804838F: f (example.c:6)
==19182==    by 0x80483AB: main (example.c:11)
==19182==  Address 0x1BA45050 is 0 bytes after a block of size 40 alloc&#39;d
==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
==19182==    by 0x8048385: f (example.c:5)
==19182==    by 0x80483AB: main (example.c:11)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Actually there will be lots of information in each message indelendently, so we need to read them seperately for
finding the detailed error, as well as the bugs related to them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The number in each message denotes the process ID, which is not the key point.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The first line of each message denotes the type of the error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The following line denotes the position of the error (as stack trace).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All the memory errors may not cause a error for compiler overall. But it is a error, as well as a bug. So it is better to treat them carefully.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memory-leak&#34;&gt;Memory Leak&lt;/h3&gt;
&lt;p&gt;Here is an example for memory leak problem.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ==19182== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
  ==19182==    at 0x1B8FF5CD: malloc (vg_replace_malloc.c:130)
  ==19182==    by 0x8048385: f (a.c:5)
  ==19182==    by 0x80483AB: main (a.c:11)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see from the stack trace where the leaked memory will be allocated, but we cannot know the reason from Memcheck directly.&lt;/p&gt;
&lt;p&gt;The leak will be divided into two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;definitely lost&amp;rdquo;: it is obvious that the memory was leaked so necessary to fix it.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;probably lost&amp;rdquo;: it also means that the memory is leaked, except some pointer oprations, which are also not smart.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;conditional-jump-or-move-depends-on-uninitialised-values&#34;&gt;&amp;ldquo;Conditional jump or move depends on uninitialised value(s)&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;This is a common message that may happen a lot, which means the uses of uninitialised values. It is difficult to find where the root cause is, but using &lt;code&gt;--track-origin=yes&lt;/code&gt; will tell us extra informations that helps us locate them.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The following part includes some typical error type from Valgrind.&lt;/p&gt;
&lt;h3 id=&#34;illegal-read--illegal-write-errors&#34;&gt;Illegal read / Illegal write errors&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Invalid read of size 4
     at 0x40F6BBCC: (within /usr/lib/libpng.so.2.1.0.9)
     by 0x40F6B804: (within /usr/lib/libpng.so.2.1.0.9)
     by 0x40B07FF4: read_png_image__FP8QImageIO (kernel/qpngio.cpp:326)
     by 0x40AC751B: QImageIO::read() (kernel/qimage.cpp:3621)
     Address 0xBFFFF0E0 is not stack&#39;d, malloc&#39;d or free&#39;d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This happens when the program reads or writes memory at a plce which Memcheck reckons it shouldn&amp;rsquo;t. Normally when you try to read or write pointed to a part that has already been freed, you&amp;rsquo;ll be informed with this message.&lt;/p&gt;
&lt;p&gt;In some cases, the program will lives well with the actually not valid access since we are allowed to read or write to a garbage area (non-fatal error). So when something goes wrong with the output, we may just check the Valgrind output to see whether there is a memory read/write error.&lt;/p&gt;
&lt;h3 id=&#34;use-of-uninitialised-values&#34;&gt;Use of uninitialised values&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Conditional jump or move depends on uninitialised value(s)
     at 0x402DFA94: _IO_vfprintf (_itoa.h:49)
     by 0x402E8476: _IO_printf (printf.c:36)
     by 0x8048472: main (tests/manuel1.c:8)
     by 0x402A6E5E: __libc_start_main (libc-start.c:129)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;`Uninitialsed value&#39; is also a common error that is not easy to find. Sometimes the variable will be read with wrong value thought the memory access is valid.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Here is an error that is not easy to be found but easy to appear: sometimes we put several judge statement in a single &lt;code&gt;if&lt;/code&gt;, then the more necessary conditions
conditions should be put first, i.e., the conditions rely on the previous one should be placed after.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;illegal-frees&#34;&gt;Illegal frees&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Invalid free()
     at 0x4004FFDF: free (vg_clientmalloc.c:577)
     by 0x80484C7: main (tests/doublefree.c:10)
     by 0x402A6E5E: __libc_start_main (libc-start.c:129)
     by 0x80483B1: (within tests/doublefree)
     Address 0x3807F7B4 is 0 bytes inside a block of size 177 free&#39;d
     at 0x4004FFDF: free (vg_clientmalloc.c:577)
     by 0x80484C7: main (tests/doublefree.c:10)
     by 0x402A6E5E: __libc_start_main (libc-start.c:129)
     by 0x80483B1: (within tests/doublefree)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Memcheck keeps track of the blocks allocated by your program with malloc/new, so it can know exactly whether or not the argument to free/delete is legitimate or not. Here, this test program has freed the same block twice. As with the illegal read/write errors, Memcheck attempts to make sense of the address free&amp;rsquo;d. If, as here, the address is one which has previously been freed, you wil be told that &amp;ndash; making duplicate frees of the same block easy to spot.&lt;/p&gt;
&lt;h3 id=&#34;overlapping-source-and-destination-blocks&#34;&gt;Overlapping source and destination blocks&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==27492== Source and destination overlap in memcpy(0xbffff294, 0xbffff280, 21)
==27492==    at 0x40026CDC: memcpy (mc_replace_strmem.c:71)
==27492==    by 0x804865A: main (overlap.c:40)
==27492==    by 0x40246335: __libc_start_main (../sysdeps/generic/libc-start.c:129)
==27492==    by 0x8048470: (within /auto/homes/njn25/grind/head6/memcheck/tests/overlap)
==27492== 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The C library functions above copy some data from one memory block to another (or something similar): memcpy(), strcpy(), strncpy(), strcat(), strncat(). The blocks pointed to by their src and dst pointers aren&amp;rsquo;t allowed to overlap. Memcheck checks for this.&lt;/p&gt;
&lt;h2 id=&#34;some-tricks&#34;&gt;Some Tricks&lt;/h2&gt;
&lt;h3 id=&#34;how-to-stop-at-the-first-error&#34;&gt;How to Stop at the First Error&lt;/h3&gt;
&lt;p&gt;If we want to stop at the console to see where the error occured:&lt;/p&gt;
&lt;p&gt;Use the parameter : &lt;code&gt;--gen-suppressions=yes&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;some-tutorials&#34;&gt;Some tutorials:&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://valgrind.org/docs/manual/manual.html&#34;&gt;https://valgrind.org/docs/manual/manual.html&lt;/a&gt;
&lt;a href=&#34;http://cs.ecs.baylor.edu/~donahoo/tools/valgrind/&#34;&gt;http://cs.ecs.baylor.edu/~donahoo/tools/valgrind/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    
  </channel>
</rss>
