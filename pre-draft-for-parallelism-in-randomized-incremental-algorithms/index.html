<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Youzhe&#39;s blogs">
    
    <link rel="shortcut icon" href="https://alanSquirrelyz.github.io/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>Pre Draft for Parallelism in Randomized Incremental Algorithms</title>
</head>
<body><header id="banner">
    <h2><a href="https://alanSquirrelyz.github.io">Youzhe Liu</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/about/" title="about">about</a>
            </li><li>
                <a href="/" title="posts">posts</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Pre Draft for Parallelism in Randomized Incremental Algorithms</h1>
        <div>
                <time>March 11, 2023</time>
            </div>
    </header><h2 id="the-paper">The Paper</h2>
<p><a href="https://arxiv.org/abs/1810.05303">Paper Link</a></p>
<p>Guy E. Blelloch, Yan Gu, Julian Shun, and Yihan Sun. 2016. Parallelism in Randomized Incremental Algorithms. In Proceedings of the 28th ACM Symposium on Parallelism in Algorithms and Architectures (SPAA &lsquo;16).</p>
<h2 id="what-is-the-paper-talking-about">What is the paper talking about</h2>
<p>The paper mainly focuses on summarizing different types of randomized incremental algorithms and the feasibility/methodology of parallelizing them. There are three types included in the paper, with some classical incremental algorithms.</p>
<h2 id="iteration-dependency">Iteration Dependency</h2>
<h3 id="preliminaries-dag">Preliminaries: DAG</h3>
<p>An iterative algorithm is an algorithm that runs in a certain sequence of steps (in order). In step $i$, there are some work $W(i)$, and also some depth $D(i)$. Specifically, step $j$ depends on step $i$ if the computation in step $j$ is affected by the step $i$. These steps can be packed (with dependencies) as a DAG.</p>
<p>Then let&rsquo;s have a look at the probability part. Since our incremental algorithm is randomized, we need to get it clear what is exactly the probabilities for each step uniformly constructed during the iterative procedure.</p>
<p>First of all, there $n!$ orders in total for $n$ steps. The presence of dependency beween any two steps $i, j$ will have a probability $p_{ij}$ event in the sample space. The thing we want to figure out is the upper bound of this probability ($\hat{p}_{ij}$). The tricky thing is that this probability upper bound here is sometimes not independent but the upper bound will always hold so we can do multiplication directly. We can do backward analysis here, considering about &ldquo;removing&rdquo; randomly selected elements one at a time from the end. We should notice that $1, &hellip;, i$ does not rely on the elements $j &gt; i$.</p>
<h3 id="type1">Type1</h3>
<blockquote>
<p>In this kind of algorithm, analyzing the dependency depth by considering all paths and get a union bound over the probability of each.</p>
</blockquote>
<h3 id="type2">Type2</h3>
<h3 id="type3">Type3</h3>
</article>

        </main><footer id="footer">
    Copyright Â© 2022 Youzhe Liu
</footer>
</body>
</html>
